function oShare = createOwnershipShare(hostIm,secretIm,key)
%createOwnershipShare creates the ownership share for visual cryptography
%using sampling distribution of means, as described by Hsu and Hou.
%Inputs:
%hostIm: a grey-level image (size M1xM2)
%secretIm: a bi-level secret image to encode (size N1xN2)
%key: seed for random number generation
%
%Output: 
%O: ownership share (size N1xN2)
%
%Requires:
%otsu_threshold.m
%
%Author: Andrew Smith
%Image Processing and Computer Vision II

%Get sizes
[hRows hCols hPlanes] = size(hostIm);
if hPlanes > 1
    hostIm = rgb2gray(hostIm);
end

[sRows sCols sPlanes] = size(secretIm);
if sPlanes > 1
    secretIm = rgb2gray(secretIm);
end

%Make sure secretIm is just bi-level
[~,secretIm] = otsu_threshold(secretIm);

%Calcualte population mean of host image
popMean = mean(mean(hostIm));

%Create big list of random numbers seeded by input key. This will generate
%50 random locations in the host image to average for each pixel location 
%in the ownership share (50 rows, 1 column, sRows*sCols planes for easy
%access)
rng(key);
randomList = randi([1,hRows*hCols], [50,1,sRows*sCols]);

%Possible blocks:
block1 = [0 1; 1 0];
block2 = [1 0; 0 1];

%Compute ownership share
%It's slightly larger than twice the size of secretIm to make up for the
%loop logic (begins at (2,2))
oShare = zeros(sRows*2+1, sCols*2+1);
counter = 1;
for r = 1:sRows
    for c = 1:sCols
        %Calculate a sample mean for a set of locations in the host image
        %generated by random numbers
        sampMean = mean(hostIm(randomList(:,:,counter)));
        
        %Determine subpixel arrangement
        if (secretIm(r,c) == 0 && sampMean < popMean) || (secretIm(r,c) == 255 && sampMean >= popMean)
            oShare(2*r:2*r+1,2*c:2*c+1) = block1;
        else
            oShare(2*r:2*r+1,2*c:2*c+1) = block2;
        end
        counter = counter + 1;
    end
end

%The loop is actually set up to start in the second space, so cut off that
%first row and column.
oShare = oShare(2:end,2:end);

end