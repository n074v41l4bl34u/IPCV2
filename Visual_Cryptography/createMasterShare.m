function mShare = createMasterShare(hostIm, oShare, key)
%mShare creates a master share for visual cryptography by sampling
%distribution of means.
%Input:
%   hostIm: Original image
%   oShare: Bi-level ownership share (see function 'createOwnershipShare').
%       Used only for size information.
%   key: Seed used to generate random numbers. This MUST be the same key
%       that was used in creating the ownership share.
%
%Output:
%   mShare: The master share, which when overlayed with the ownership share,
%       reveals the secret image.
%
%Author: Andrew Smith
%Image Processing and Computer Vision II

%Obtain size information of inputs
[hRows hCols hPlanes] = size(hostIm);
if hPlanes > 1
    hostIm = rgb2gray(hostIm);
end

[oRows oCols oPlanes] = size(oShare);
if (oPlanes > 1)
    error('Ownership share must be generated by function ''createOwnershipShare,'' resulting in a single-plane, bi-level image.');
end

%Calculate population mean of host image
popMean = mean(mean(hostIm));

%Create big list of random numbers seeded by input key. This will generate
%50 random locations in the host image to average for each pixel location 
%in the master share (50 rows, 1 column, oRows*oCols planes for easy
%access)
rng(key);
randomList = randi([1,hRows*hCols], [50,1,oRows*oCols]);

mShare = zeros(size(oRows+1,oCols+1));
block1 = [0 1; 1 0];
block2 = [1 0; 0 1];
counter = 1;
for r = 1:oRows/2
    for c = 1:oCols/2
        %Calculate a sample mean for a set of locations in the host image
        %generated by random numbers
        sampMean = mean(hostIm(randomList(:,:,counter)));
        
        %Determine subpixel arrangement
        if sampMean < popMean
            mShare(2*r:2*r+1,2*c:2*c+1) = block1;
        else
            mShare(2*r:2*r+1,2*c:2*c+1) = block2;
        end
        counter = counter + 1;
    end
end

%The loop is actually set up to start in the second space, so cut off that
%first row and column.
mShare = mShare(2:end,2:end);

end